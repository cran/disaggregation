<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Anita Nandi" />

<meta name="date" content="2023-04-28" />

<title>A short introduction to the disaggregation package</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">A short introduction to the disaggregation package</h1>
<h4 class="author">Anita Nandi</h4>
<h4 class="date">2023-04-28</h4>



<p>The <strong>disaggregation</strong> package contains functions to run Bayesian disaggregation models. Aggregated response data over large heterogenous regions can be used alongside fine-scale covariate information to predict fine-scale response across the region. The github page for this package can be found <a href="https://github.com/aknandi/disaggregation">here</a>.</p>
<p>Install <strong>disaggregation</strong> using:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">install.packages</span>(<span class="st">&#39;disaggregation&#39;</span>)</span></code></pre></div>
<p>or from github using</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>devtools<span class="op">::</span><span class="kw">install_github</span>(<span class="st">&quot;aknandi/disaggregation&quot;</span>)</span></code></pre></div>
<p>The key functions are <code>prepare_data</code>, <code>fit_model</code> and <code>predict</code>. The <code>prepare_data</code> function takes the aggregated data and covariate data to be used in the model and produces an object to be use by <code>fit_model</code>. This functions runs the disaggregation model and the out can be passed to <code>predict</code> to produce fine-scale predicted maps of the response variable.</p>
<p>To use the disaggregation <code>prepare_data</code> function, you must have the aggregated data as a <code>SpatialPolygonDataFrame</code> object and a <code>RasterStack</code> of the covariate data to be used in the model.</p>
<div id="example" class="section level2">
<h2>Example</h2>
<p>We will demonstrate an example of the <strong>disaggregation</strong> package using areal data of leukemia incidence in New York, using data from the package <code>SpatialEpi</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">library</span>(SpatialEpi, <span class="dt">quietly =</span> <span class="ot">TRUE</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">library</span>(dplyr, <span class="dt">quietly =</span> <span class="ot">TRUE</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">library</span>(sp, <span class="dt">quietly =</span> <span class="ot">TRUE</span>) </span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">library</span>(raster, <span class="dt">quietly =</span> <span class="ot">TRUE</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">library</span>(disaggregation, <span class="dt">quietly =</span> <span class="ot">TRUE</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a>map &lt;-<span class="st"> </span>NYleukemia<span class="op">$</span>spatial.polygon</span>
<span id="cb3-8"><a href="#cb3-8"></a>df &lt;-<span class="st"> </span>NYleukemia<span class="op">$</span>data</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a>polygon_data &lt;-<span class="st"> </span><span class="kw">SpatialPolygonsDataFrame</span>(map, df)</span>
<span id="cb3-11"><a href="#cb3-11"></a>polygon_data</span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">#&gt; class       : SpatialPolygonsDataFrame </span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co">#&gt; features    : 281 </span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">#&gt; extent      : -76.73743, -75.2395, 41.9978, 43.41827  (xmin, xmax, ymin, ymax)</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">#&gt; crs         : +proj=longlat </span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">#&gt; variables   : 3</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">#&gt; names       : censustract.FIPS,   cases, population </span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="co">#&gt; min values  :      36007000100, 0.00014,          9 </span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="co">#&gt; max values  :      36109992300, 9.28601,      13015</span></span></code></pre></div>
<p>Now we simulate two covariate rasters for the area of interest and make a <code>RasterStack</code>. They are simulated at the resolution of approximately 1km2.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>extent_in_km &lt;-<span class="st"> </span><span class="dv">111</span><span class="op">*</span>(polygon_data<span class="op">@</span>bbox[, <span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>polygon_data<span class="op">@</span>bbox[, <span class="dv">1</span>])</span>
<span id="cb4-2"><a href="#cb4-2"></a>n_pixels_x &lt;-<span class="st"> </span><span class="kw">floor</span>(extent_in_km[[<span class="dv">1</span>]])</span>
<span id="cb4-3"><a href="#cb4-3"></a>n_pixels_y &lt;-<span class="st"> </span><span class="kw">floor</span>(extent_in_km[[<span class="dv">2</span>]])</span>
<span id="cb4-4"><a href="#cb4-4"></a>r &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">raster</span>(<span class="dt">ncol =</span> n_pixels_x, <span class="dt">nrow =</span> n_pixels_y)</span>
<span id="cb4-5"><a href="#cb4-5"></a>r &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">setExtent</span>(r, raster<span class="op">::</span><span class="kw">extent</span>(polygon_data))</span>
<span id="cb4-6"><a href="#cb4-6"></a>r[] &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span><span class="op">:</span>raster<span class="op">::</span><span class="kw">ncell</span>(r), <span class="cf">function</span>(x) <span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="kw">ifelse</span>(x <span class="op">%%</span><span class="st"> </span>n_pixels_x <span class="op">!=</span><span class="st"> </span><span class="dv">0</span>, x <span class="op">%%</span><span class="st"> </span>n_pixels_x, n_pixels_x), <span class="dv">3</span>))</span>
<span id="cb4-7"><a href="#cb4-7"></a>r2 &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">raster</span>(<span class="dt">ncol =</span> n_pixels_x, <span class="dt">nrow =</span> n_pixels_y)</span>
<span id="cb4-8"><a href="#cb4-8"></a>r2 &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">setExtent</span>(r2, raster<span class="op">::</span><span class="kw">extent</span>(polygon_data))</span>
<span id="cb4-9"><a href="#cb4-9"></a>r2[] &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span><span class="op">:</span>raster<span class="op">::</span><span class="kw">ncell</span>(r), <span class="cf">function</span>(x) <span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="kw">ceiling</span>(x<span class="op">/</span>n_pixels_y), <span class="dv">3</span>))</span>
<span id="cb4-10"><a href="#cb4-10"></a>cov_stack &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">stack</span>(r, r2)</span>
<span id="cb4-11"><a href="#cb4-11"></a>cov_stack &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">scale</span>(cov_stack)</span></code></pre></div>
<p>We also create a population raster. This is to allow the model to correctly aggregated the pixel values to the polygon level. For this simple example we assume that the population within each polygon is uniformly distributed.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>extracted &lt;-<span class="st"> </span>raster<span class="op">::</span><span class="kw">extract</span>(r, polygon_data)</span>
<span id="cb5-2"><a href="#cb5-2"></a>n_cells &lt;-<span class="st"> </span><span class="kw">sapply</span>(extracted, length)</span>
<span id="cb5-3"><a href="#cb5-3"></a>polygon_data<span class="op">@</span>data<span class="op">$</span>pop_per_cell &lt;-<span class="st"> </span>polygon_data<span class="op">@</span>data<span class="op">$</span>population<span class="op">/</span>n_cells</span>
<span id="cb5-4"><a href="#cb5-4"></a>pop_raster &lt;-<span class="st"> </span><span class="kw">rasterize</span>(polygon_data, cov_stack, <span class="dt">field =</span> <span class="st">&#39;pop_per_cell&#39;</span>)</span></code></pre></div>
<p>To correct small inconsistencies in the polygon geometry, we run the line below</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>polygon_data &lt;-<span class="st"> </span>rgeos<span class="op">::</span><span class="kw">gBuffer</span>(polygon_data, <span class="dt">byid =</span> <span class="ot">TRUE</span>, <span class="dt">width =</span> <span class="dv">0</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co">#&gt; Warning: GEOS support is provided by the sf and terra packages among others</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">#&gt; Warning in rgeos::gBuffer(polygon_data, byid = TRUE, width = 0): Spatial object</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">#&gt; is not projected; GEOS expects planar coordinates</span></span></code></pre></div>
<p>Now we have setup the data we can use the <code>prepare_data</code> function to create the objects needed to run the disaggregation model. The name of the response variable and id variable in the <code>SpatialPolygonsDataFrame</code> should be specified.</p>
<p>The user can also control the parameters of the mesh that is used to create the spatial field. The mesh is created by finding a tight boundary around the polygon data, and creating a fine mesh within the boundary and a coarser mesh outside. This speeds up computation time by only having a very fine mesh within the area of interest and having a small region outside with a coarser mesh to avoid edge effects. The mesh parameters: <code>concave</code>, <code>convex</code> and <code>resolution</code> refer to the parameters used to create the mesh boundary using the <a href="https://rdrr.io/github/andrewzm/INLA/man/inla.nonconvex.hull.html">inla.noncovex.hull function</a>, while the mesh parameters <code>max.edge</code>, <code>cut</code> and <code>offset</code> refer to the parameters used to create the mesh using the <a href="https://rdrr.io/github/andrewzm/INLA/man/inla.mesh.2d.html">inla.mesh.2d function</a>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>data_for_model &lt;-<span class="st"> </span><span class="kw">prepare_data</span>(polygon_data,</span>
<span id="cb7-2"><a href="#cb7-2"></a>                               cov_stack,</span>
<span id="cb7-3"><a href="#cb7-3"></a>                               pop_raster,</span>
<span id="cb7-4"><a href="#cb7-4"></a>                               <span class="dt">response_var =</span> <span class="st">&#39;cases&#39;</span>,</span>
<span id="cb7-5"><a href="#cb7-5"></a>                               <span class="dt">id_var =</span> <span class="st">&#39;censustract.FIPS&#39;</span>,</span>
<span id="cb7-6"><a href="#cb7-6"></a>                               <span class="dt">mesh.args =</span> <span class="kw">list</span>(<span class="dt">cut =</span> <span class="fl">0.01</span>,</span>
<span id="cb7-7"><a href="#cb7-7"></a>                                                <span class="dt">offset =</span> <span class="kw">c</span>(<span class="fl">0.1</span>, <span class="fl">0.5</span>),</span>
<span id="cb7-8"><a href="#cb7-8"></a>                                                <span class="dt">max.edge =</span> <span class="kw">c</span>(<span class="fl">0.1</span>, <span class="fl">0.2</span>),</span>
<span id="cb7-9"><a href="#cb7-9"></a>                                                <span class="dt">resolution =</span> <span class="dv">250</span>),</span>
<span id="cb7-10"><a href="#cb7-10"></a>                               <span class="dt">na.action =</span> <span class="ot">TRUE</span>,</span>
<span id="cb7-11"><a href="#cb7-11"></a>                               <span class="dt">ncores =</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">plot</span>(data_for_model)</span></code></pre></div>
<p>Now have our data object we are ready to run the model. Here we can specify the likelihood function as gaussian, binomial or poisson, and we can specify the link function as logit, log or identity. The disaggregation model makes predictions at the pixel level:</p>
<p><span class="math inline">\(link(pred_i) = \beta_0 + \beta X + GP(s_i) + u_i\)</span></p>
<p>where <span class="math inline">\(X\)</span> are the covariates, <span class="math inline">\(GP\)</span> is the gaussian random field and <span class="math inline">\(u_i\)</span> is the iid random effect. The pixel predictions are then aggregated to the polygon level using the weighted sum (via the aggregation raster, <span class="math inline">\(agg_i\)</span>):</p>
<p><span class="math inline">\(cases_j = \sum_{i \epsilon j} pred_i \times agg_i\)</span></p>
<p><span class="math inline">\(rate_j = \frac{\sum_{i \epsilon j} pred_i \times agg_i}{\sum_{i \epsilon j} agg_i}\)</span></p>
<p>The different likelihood correspond to slightly different models (<span class="math inline">\(y_j\)</span> is the response count data):</p>
<p><strong>Gaussian</strong> (<span class="math inline">\(\sigma_j\)</span> is the dispersion of the polygon data),</p>
<p><span class="math inline">\(dnorm(y_j/\sum agg_i, rate_j, \sigma_j)\)</span></p>
<p>Here <span class="math inline">\(\sigma_j = \sigma \sqrt{\sum agg_i^2} / \sum agg_i\)</span>, where <span class="math inline">\(\sigma\)</span> is the dispersion of the pixel data, a parameter learnt by the model.</p>
<p><strong>Binomial</strong> (For a survey in polygon j, <span class="math inline">\(y_j\)</span> is the number positive and <span class="math inline">\(N_j\)</span> is the number tested)</p>
<p><span class="math inline">\(dbinom(y_j, N_j, rate_j)\)</span></p>
<p><strong>Poisson</strong> (predicts incidence count)</p>
<p><span class="math inline">\(dpois(y_j, cases_j)\)</span></p>
<p>The user can also specify the priors for the regression parameters. For the field, the user specifies the pc priors for the range, <span class="math inline">\(\rho_{min}\)</span> and <span class="math inline">\(\rho_{prob}\)</span>, where <span class="math inline">\(P(\rho &lt; \rho_{min}) = \rho_{prob}\)</span>, and the variation, <span class="math inline">\(\sigma_{min}\)</span> and <span class="math inline">\(\sigma_{prob}\)</span>, where <span class="math inline">\(P(\sigma &gt; \sigma_{min}) = \sigma_{prob}\)</span>, in the field. For the iid effect, the user also specifies pc priors.</p>
<p>By default the model contains a spatial field and a polygon iid effect. These can be turned off in the <code>disag_model</code> function, using <code>field = FALSE</code> or <code>iid = FALSE</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>model_result &lt;-<span class="st"> </span><span class="kw">disag_model</span>(data_for_model,</span>
<span id="cb9-2"><a href="#cb9-2"></a>                            <span class="dt">iterations =</span> <span class="dv">1000</span>,</span>
<span id="cb9-3"><a href="#cb9-3"></a>                            <span class="dt">family =</span> <span class="st">&#39;poisson&#39;</span>,</span>
<span id="cb9-4"><a href="#cb9-4"></a>                            <span class="dt">link =</span> <span class="st">&#39;log&#39;</span>,</span>
<span id="cb9-5"><a href="#cb9-5"></a>                            <span class="dt">priors =</span> <span class="kw">list</span>(<span class="dt">priormean_intercept =</span> <span class="dv">0</span>,</span>
<span id="cb9-6"><a href="#cb9-6"></a>                                          <span class="dt">priorsd_intercept =</span> <span class="dv">2</span>,</span>
<span id="cb9-7"><a href="#cb9-7"></a>                                          <span class="dt">priormean_slope =</span> <span class="fl">0.0</span>,</span>
<span id="cb9-8"><a href="#cb9-8"></a>                                          <span class="dt">priorsd_slope =</span> <span class="fl">0.4</span>,</span>
<span id="cb9-9"><a href="#cb9-9"></a>                                          <span class="dt">prior_rho_min =</span> <span class="dv">3</span>,</span>
<span id="cb9-10"><a href="#cb9-10"></a>                                          <span class="dt">prior_rho_prob =</span> <span class="fl">0.01</span>,</span>
<span id="cb9-11"><a href="#cb9-11"></a>                                          <span class="dt">prior_sigma_max =</span> <span class="dv">1</span>,</span>
<span id="cb9-12"><a href="#cb9-12"></a>                                          <span class="dt">prior_sigma_prob =</span> <span class="fl">0.01</span>,</span>
<span id="cb9-13"><a href="#cb9-13"></a>                                          <span class="dt">prior_iideffect_sd_max =</span> <span class="fl">0.05</span>,</span>
<span id="cb9-14"><a href="#cb9-14"></a>                                          <span class="dt">prior_iideffect_sd_prob =</span> <span class="fl">0.01</span>))</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">plot</span>(model_result)</span></code></pre></div>
<p>Now we have the results from the model of the fitted parameters, we can predict Leukemia incidence rate at fine-scale (the scale of the covariate data) across New York. The <code>predict</code> function takes the model result and predicts both the mean raster surface and predicts and summarises <code>N</code> parameter draws, where <code>N</code> is set by the user (default 100). The uncertainty is summarised via the confidence interval set by the user (default 95% CI).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>preds &lt;-<span class="st"> </span><span class="kw">predict</span>(model_result, </span>
<span id="cb11-2"><a href="#cb11-2"></a>                 <span class="dt">N =</span> <span class="dv">100</span>, </span>
<span id="cb11-3"><a href="#cb11-3"></a>                 <span class="dt">CI =</span> <span class="fl">0.95</span>)</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="kw">plot</span>(preds)</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
